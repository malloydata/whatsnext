# WN 0013 - Schema Definitions in Malloy

- **Status**: *Draft* 
- **Discussions-To:**  _Slack
- **Author:** lloyd tabb

# Allow Malloy to operate without reading Schema from the Database.
There are a number of times when we'd like to write Malloy and we don't have access to the schema in the database.  In these cases it would be great if we could verify that the Model was capable of compiling and could be used without connectivity to the database. These cases include:

* Tables are generated by some pipeline that hasn't run yet, but we want to compile Malloy anyway.
* The build task doesn't have permissions to access the database
* We're converting from some other language that doesn't know the structure of the table but it will be available when we actually run the query.
* We don't want all the columns in a table to be available in Malloy, just the ones we declare.
* We want to edit the nested structures that are available in Malloy.

We also have the additional problem in that sometimes we want to add annotations to an existing column in a Malloy model.

## Proposal

There are basically two gestures added to the language `table_only` just collects the URL for the table but doesn't read the schema.  `column_xxxx` is an expression that says the the source of the data comes from the table.  For basic fields, we'll need the type. We should use the same syntax to get to native types.

The syntax here may or may not be close.  The reason i

```
source: airports is duckdb.table_only('airports.parquet') extend {
    dimension: 
        code is column!string
        full_name is column!string
        elevation is column!number
        atc_data is column!date
        big_number is column!"numeric" -- intrinsic types might be important
}
```

## Arrays and Structs
We'll also want to be able to declare arrays and structs.

source: airports is duckdb.table_only('order.parquet') extend {
    dimension: 
        id is column!number
        order_date is column!date

    struct_array: items is {
        id is column!number
        product is column!string
    }
    
    array: categories is column!string

    struct: users i {
        name is column:string
        age is column:number
    }
}
```

## Redeclaring for annotation
You can declare something as a column it won't create a new dimension, just map on top of the existing declaration so you an add annotations.  Below we use 'table' to import the schema.  `code` will already be there, 

```
-- import from a table
source: airports is duckdb.table('airports.parquet') extend {
    dimension: 
        # label='FAA Code'
        code is column
}
```