# WN 0015 - Arrays and Records

- **Status**: *Draft*
- **Discussions-To:**  [Slack/malloy-language](https://malloy-community.slack.com/archives/C06JR0C23RB/p1722981665815069)
- **Author:** Michael Toy\<michaeltoy@meta.com>
- **Experiment-ID:** _NOID_YET_

# Record operations

> Note: duckdb and bigquery call these "STRUCT" which is a C/C++ ism. Presto calls them a "ROW". I don't know what word I want to choose but I am avoiding "struct" because that is going to be confusing when a "StructDef" or "StructRelationship" have  nothing to do with a "struct" internally.

A record is a set of key value pairs. As a table column, a record treated exactly like a one-to-one join is in Malloy.

## Record references

| Expression | Meaning |
| --- | --- |
| `recordField` | Mostly for `select:`, the entire field |
| `recordField.componentName` | The `componentName` field in the record |
| `{ name: 'Mark', 'source': 'referral' }` <br/>``{ name is 'Mark', `source` is 'referral' }`` | Record literal <blockquote>Note: Not sure about "is" vs JSON |
| `{ name, 'source' }` | Record literal where key is implied from reference |

> Note: Lloyd suggested `name is 'Mark'` instead of the JSON-esque syntax. This is another example of something that is Malloy-like vs. something that is SQL like and I am shocked to discover that this time I am siding with the SQL people who don't want to learn new things. This should at least be considered because function argument syntax is so similar.

## Query Usage

| Expression | Meaning |
| --- | --- |
| `select: recordField` | Adds the record field to the output |
| `select: recordField.*` | Expands the record and adds each field to the output |
| `group_by: recordField.*` | Expands the record and adds each field to the output |
| `group_by: recordField` | <blockquote>Note: ???</blockquote> |

> Note: I think `group_by: x.*` on a complex nested record would probably error, but we could do simple ones. Might even be database specific

## Type description

> Note: Not sure we ever have a need to cast to a record type, but for completeness

Record types are written `<id::type1, id::type2, id::type3 ..., id::typen>` for example

    <firstName:: string, lastName:: string, age:: number>

> Note: Chris doesn't like `<>`

# Array Operations

Arrays are treated like a `join_many:` in Malloy.

## Array references

| Expression | Meaning |
| --- | --- |
| `arrayObj` | The entire array as an object |
| `arrayObj[n]` | The element at offset `n` in the array |
| `[n1, n2, n3]` | Literal for an array with three elements |

> Note: No help in finding last element of array other than length(array)-1, objections exist to using some sigil and to using -1. Use the function `at_offset()` for that.

## Query Usage

| Expression | Meaning |
| --- | --- |
| `select: arrayObj` | Adds the array to the output |
| `group_by: arrayObj` | <blockquote>Note: ???<blockquote> |
| `group_by: arrayObj.*` | <blockquote>Note: ???<blockquote> |

## Other syntactic support

One can imagine other uses of expressions (instead of functions) on array operations ...
maybe even if we like some of those, they don't go in the MVP. Here are just a few
examples off of the top of my head.

| Expression | Meaning |
| --- | --- |
| `x + y` | Concatenate the X and the Y array |
| `x = [ 2, 3 ]` | True if x equals the array `[2,3]` |
| `x ~ [ 2, 3 ]` | True if x contains the sub-array `[2,3]` |
| `x ~ 2` | True if x contains `2` |


## Function Operations

There is a set of functions which take arrays as arguments which Malloy provides
translations for in every dialect.

> Note: It has been suggested to extend the syntax of Malloy to allow a
> method like invocation `objName.split(seperator)`. This feels like
> an an entire new can of worms because we would want to make sure
> this could be implemented and didn't introduce new namespace problems
> since this would be yet another use of the increasingly ambiguous
> dot operator.

I am not sure which of these are essential. I have yet to do a survey of arrays
in all databases to see what capabilities they have. I have started with common
array operations in computer languages, maybe not all of these make sense
for database arrays.

| Function | Meaning |
| --- | --- |
| `split(string, seperator)` | Split a string into an array, using the separator |
| `join(array, seperator)` | Join an array of strings into a string, using the separator |
| `find_first(array, element)` | Look for the element in the array from the beginning, return the index |
| `find_last(array, element)` | Look for the element in the array from the end, return the index |
| `concat(array, array)` | Make a new array from two arrays |
| `filter(split(address, ' ') {where: each ~ 'street' \| 'lane' \| 'court'}`) | <blockquote>Note: unsure of syntax for filters, need to reconcile with joins</blockquote> |
| `length(array)` | Number of entries |
| `slice(array,x)` | The array starting at offset `x`, to the end |
| `slice(array, x, y)` | The array starting at offset `x`, ending at offset `y` |
| `span(array, x, l)` | The array starting at offset `x`, for `l` characters |
| `at_offset(array, x` | The array element starting at offset `x` |

> Note: Names are not important at this point, the operations list for which we need
> names is more important at this stage than what we call the operations.

> Note: 0 is the offset first character? Offset of -1 means "the last character", -2 "second to last", etc ...

> Note: `contains`/`includes`, `push`, and `unshift` could all be implemented with these functions but maybe we want to provide them for easy reading


## Arrays of Records

As with a source joined with `join_many:`, an access to a field from an array of records
(e.g. `arrayName.recFieldName`) implies and un-nesting of that record and subsequent
expansion of the query.

## Aggregate operations

| Function | Meaning |
| --- | --- |
| `arrayName.recFieldName.sum()` | Sum of all the `recFieldName` from each entry in the array |
| `arrayName.sum(math_function(arrayName.recFieldName))` | Sum of passing each `recFieldName` to `math_function()` |

## Query Operations

| Function | Meaning |
| --- | --- |
| `select: arrayName` | Select the entire array into the output |
  `select: arrayName.fieldName` | show the all the values of fieldname for each row |
| `select: arrayName.*` | Select each key from the record |
| `groupBy: arrayName` | <blockquote>Note: ???</blockquote> |
  `group_by: arrayName.fieldName` | Group by each `fieldName` |
| `groupBy: arrayName.*` | <blockquote>Note: ???</blockquote> |
| `groupBy: arrayName.each` | <blockquote>Note: If `group_by: recordField` worked then maybe this would work?<blockquote>|

## Arrays of Scalars

The pseudo field `each` is used to indicate a reference to the array which is intended to
un-nest the contents of the array.

## Aggregate operations

| Function | Meaning |
| --- | --- |
| `arrayName.each` | In an aggregate computation, the un-nested value for each row |
| `intArray.each.sum()` | Sum of the contents of the array |
| `intArray.sum(math_funciton(intArray.each))` | Sum of the result of `math_function()` on each entry in the array |

## Query Operations

| Function | Meaning |
| --- | --- |
| `select: arrayName` | Select the entire array into the output |
| `select: arrayName.each` | <blockquote>Note: ???</blockquote> |
| `groupBy: arrayName` | <blockquote>Note: ???</blockquote> |
| `groupBy: arrayName.each` | <blockquote>Note: ???</blockquote> |


## Type description

Array types are written `TYPENAME[]` for example, `string[]` or `<firstName::string, lastName::string, age::number>[]`

# MVP ???

> Note: Once there is consensus about the syntax for all the things the very next question is "what are the steps to get there", and in particular is there a first step which moves the bar for users.

# Subselects

Don't know if this belongs here or in it's own WN. Putting it here because it came up in conversation, suspect it is it's own WN ...

> Note: This is a just a placeholder

### Lloyd brain dumps
```
dimension: road_types is  split(address, ' ') -> {
  where: each ~ 'street' | 'lane
  select:each
}
dimension: city_parts is split(city,' ') -> {
  where: each ~r'[A-Z]'
  select: each is lower(each)
}
// as a dimensional scalar value
dimension: city_words is split(city,' ') -> { aggregate: return is count() }
```

... need to think about how this works with joins and repeated records before I comment on now well this works for value arrays.

###

There are three things happening here

1. A subquery, if it returns multiple rows, returns an array type
2. A new subqueryu query type `return:` exists to return a dimensional value
3. When an array is passed to a subquery, there is a variable inside the subquery which refers to one row of the array, and that row is the type of one row in the array and it has the name `each`

I wonder if we should give the user the chance to name the varibale, like in the ruby block gesture `{ |arg| arg*10 }`. That way there is no problem if the array is an array of arrays and we see something like `each.each` and wonder what that means.

```
// type of one_row is inferred from array type, doesn't need to be specified ...

dimesnsion: filtered_array is array -> (one_row) {
  where: one_row.color != 'blue'
  select: one_row
}

dimension: array_size is array -> (one_row) { return: one_row.count() }
```
