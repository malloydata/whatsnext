# WN 0015 - Arrays and Records

- **Status**: *Draft*
- **Discussions-To:**  [Slack/malloy-language](https://malloy-community.slack.com/archives/C06JR0C23RB/p1722981665815069)
- **Author:** Michael Toy\<michaeltoy@meta.com>
- **Experiment-ID:** _NOID_YET_

# Records

A record is a set of key value pairs. As a table column, a record treated exactly like `join_one:` is in Malloy.

## Record references

| Expression | Meaning |
| --- | --- |
| `recordField` | Mostly for `select:`, the entire field |
| `recordField.componentName` | The `componentName` field in the record |
| ``{name is 'Mark', `source` is 'referral'}`` | Record literal |
| ``{name, `source`}`` | Record literal where key is implied from reference |

## Type description

Record types are written `{id::type1, id::type2, id::type3 ..., id::type}` for example

    {firstName::string, lastName::string, age::number}

# Arrays

There are two ways that arrays can be used in Malloy.

  * A purely dimensional array can be selected, grouped, and passed as an argument to functions. A row in
    a query which as dimensional array values simply has one column with an array value.
  * A joined array can be treated as if the object was integrated into the source with `join_many:` Thus
    a row in a query which contains a joined array will expand to multiple rows in the output,
    one row for each value in the joined array.

> Note: I don't know what to call these two things, and if that is the correct keyword.

## Array Expressions

| Expression | Meaning |
| --- | --- |
| `arrayObj` | The entire array as an object |
| `[n1, n2, n3]` | Literal for an array with three elements |

## Other syntactic support

One can imagine other uses of expressions (instead of functions) on array operations ...
maybe even if we like some of those, they don't go in the MVP. Here are just a few
examples off of the top of my head.

| Expression | Meaning |
| --- | --- |
| `x + y` | Concatenate the X and the Y array |
| `x = [ 2, 3 ]` | True if x equals the array `[2,3]` |
| `x ~ [ 2, 3 ]` | True if x contains the sub-array `[2,3]` |
| `x ~ 2` | True if x contains `2` |

## Adding arrays to a source

When reading the schema of an existing table, all arrays are assumed to be joined arrays.
The there is also syntax for adding a new joined array to a source.

    join_array: numbers is concat(even_numbers, odd_numbers)

A dimensional array is declared with `dimension:` as in

    dimension: numbers_as_a_dimension is concat(even_numbers, odd_numbers)

## Function Operations

There is a set of functions which take arrays as arguments which Malloy provides
translations for in every dialect.

I am not sure which of these are essential. I have yet to do a survey of arrays
in all databases to see what capabilities they have. I have started with common
array operations in computer languages, maybe not all of these make sense
for database arrays.

| Function | Meaning |
| --- | --- |
| `split(string, seperator)` | Split a string into an array, using the separator |
| `join(array, seperator)` | Join an array of strings into a string, using the separator |
| `find_first(array, element)` | Look for the element in the array from the beginning, return the index |
| `find_last(array, element)` | Look for the element in the array from the end, return the index |
| `concat(array, array)` | Make a new array from two arrays |
| `filter(split(address, ' ') {where: each ~ 'street' \| 'lane' \| 'court'}`) | <blockquote>Note: unsure of syntax for filters, need to reconcile with joins</blockquote> |
| `length(array)` | Number of entries |
| `slice(array,x)` | The array starting at offset `x`, to the end |
| `slice(array, x, y)` | The array starting at offset `x`, ending at offset `y` |
| `span(array, x, l)` | The array starting at offset `x`, for `l` characters |
| `at_offset(array, x` | The array element starting at offset `x` (0 is first element)|
| `contains(array, x)` | True if the one of the elements in the array is equal to x |


## Arrays of Records

If an array of records is a joined array, it works much like a source joined with `join_many:`, an access to a field from an array of records (e.g. `arrayName.recFieldName`) implies and un-nesting of that record and subsequent expansion of the query.

###  Aggregate operations

| Function | Meaning |
| --- | --- |
| `arrayName.recFieldName.sum()` | Sum of all the `recFieldName` from each entry in the array |
| `arrayName.sum(math_function(arrayName.recFieldName))` | Sum of passing each `recFieldName` to `math_function()` |

## Query Operations

| Function | Meaning |
| --- | --- |
| `select: value is arrayName.each` | Un-nest the array into a column |

## Arrays of Scalars

The pseudo field `each` is used to indicate a reference to the array which is intended to
un-nest the contents of the array.

## Aggregate operations

| Function | Meaning |
| --- | --- |
| `arrayName.each` | In an aggregate computation, the un-nested value for each row |
| `intArray.each.sum()` | Sum of the contents of the array |
| `intArray.sum(math_funciton(intArray.each))` | Sum of the result of `math_function()` on each entry in the array |

## Query Operations

| Function | Meaning |
| --- | --- |
| `select: arrayName.each` |  |

## Type description

Array types are written `TYPENAME[]` for example, `string[]` or `{firstName::string, lastName::string, age::number}[]`
