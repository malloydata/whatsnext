# WN 0023 - Malloy Shared Configuration

- **Status**: *Draft*
- **Discussions-To:** TBD
- **Author:** Michael Toy

## Overview

Malloy tools — the VSCode extension, the builder CLI, and potentially others — need to agree on database connection configurations. This WN defines a shared configuration file format for that purpose.

The configuration file defines named database connections and optionally defines **modes** — named environment variants that override connection settings. It uses the MOTLY (Malloy Tag Language) format because it is hand-edited by developers and MOTLY is cleaner than JSON for that purpose.

While the configuration file itself is a convention shared between tools, the Malloy core (`@malloydata/malloy`) provides the **connection registry** — a mechanism that parses a configuration string and returns a ready-to-use connection resolver. Connection packages register their factory functions on import, and the core handles the rest. Applications only need to import the connection packages they support and call `Malloy.parseConnections()`.

## The Configuration File

The configuration file is named `malloy-config.motly`. It uses the MOTLY (Malloy Tag Language) format.

A minimal configuration declares one connection:

```motly
Connections: {
  duckdb: {
    is = duckdb
  }
}
```

A more complete example:

```motly
Connections: {
  warehouse: {
    is = bigquery
    defaultProjectId = "${GCP_PROJECT}"
    location = US
  }
  logs: {
    is = postgres
    host = "${PG_HOST}"
    port = 5432
    databaseName = analytics
    userName = "${PG_USER}"
    password = "${PG_PASSWORD}"
  }
  local: {
    is = duckdb
  }
}

Modes: {
  user: {
    Connections: {
      warehouse: {
        is = duckdb
        path = "./data/warehouse-sample.db"
      }
      logs: {
        is = duckdb
        path = "./data/logs-sample.db"
      }
    }
  }
  staging: {
    Connections: {
      warehouse: {
        defaultProjectId = "${GCP_PROJECT}"
        dataset = staging_analytics
      }
      logs: {
        host = "${STAGING_PG_HOST}"
      }
    }
  }
  production: {
  }
}
```

### MOTLY Conventions

The configuration file follows these MOTLY conventions:

- **Capitalized names** are structural keywords: `Connections:`, `Modes:`
- **Lowercase names** are user-defined: `warehouse:`, `staging:`, `local:`
- **Colon + braces** denote something with properties: `name: { ... }`
- **Equals** assigns a scalar value: `is = duckdb`, `port = 5432`
- **Quoted strings** for values containing anything beyond alphanumeric characters and underscores: `"${GCP_PROJECT}"`, `"./data/local.db"`
- **Unquoted strings** for simple identifiers: `bigquery`, `duckdb`, `US`

## Connections

The `Connections:` section declares named database connections. Malloy models reference connections by name (e.g., `source: foo is warehouse.table('orders')`), and the configuration file provides the actual settings for each name.

### Connection Types

Each connection has an `is` property that identifies which connection package handles it, along with connection-specific properties. The `is` value corresponds to a registered connection factory (see **Connection Registry** below).

| Type | Key Properties |
|------|----------------|
| `duckdb` | `path`, attached databases |
| `bigquery` | `defaultProjectId`, `billingProjectId`, `location`, `serviceAccountKeyJson` |
| `postgres` | `host`, `port`, `databaseName`, `userName`, `password` (or `connectionString`) |
| `snowflake` | `account`, `username`, `password`/`privateKey`, `warehouse`, `database`, `schema` |
| `trino` | `server`, `port`, `catalog`, `schema`, `user`, `password` |
| `mysql` | `host`, `port`, `database`, `user`, `password` |
| `motherduck` | `accessToken`, `database` |

DuckDB connections can also attach external databases (BigQuery, Snowflake, Postgres, S3, GCS) as named databases, following the existing DuckDB attached-databases pattern.

### Environment Variable Substitution

All string values support `${VAR_NAME}` substitution. The variable must exist in the environment or the configuration file fails to load. This is the mechanism for keeping secrets out of the file.

```motly
Connections: {
  warehouse: {
    is = bigquery
    defaultProjectId = "${GCP_PROJECT}"
    serviceAccountKeyJson = "${BQ_SERVICE_ACCOUNT_KEY}"
  }
}
```

## Modes

The `Modes:` section defines named configurations that override connection settings. A mode allows the same Malloy models to run against different databases depending on the context — local development, staging, production, or any other environment a team defines.

### How Modes Work

Each mode can override any connection declared in the top-level `Connections:` section. Overrides can be full replacements (changing the connection entirely) or partial patches (changing just one property):

```motly
Modes: {
  user: {
    Connections: {
      # Full replacement: BigQuery → local DuckDB
      warehouse: {
        is = duckdb
        path = "./data/warehouse-sample.db"
      }
    }
  }
  staging: {
    Connections: {
      # Partial override: same type, different dataset
      warehouse: {
        dataset = staging_analytics
      }
    }
  }
}
```

Connections not mentioned in a mode inherit from the top-level `Connections:` section unchanged.

### Mode Selection

The configuration file declares what modes **exist**. Which mode is **active** is determined by the application:

- **VSCode extension**: Mode picker in the status bar or settings
- **CLI tools**: `--mode` flag (e.g., `malloy build --mode staging`)
- **Default**: When no mode is specified, the top-level connections are used directly

The configuration file does not specify a default mode. Applications may have their own default behavior.

### Modes Are User-Defined

Modes are not a fixed set. A configuration defines whatever modes make sense for its workflow. A small project might have no modes at all. A large organization might have:

```motly
Modes: {
  user: { ... }
  team_staging: { ... }
  corp_staging: { ... }
  production: { ... }
}
```

Adding a new mode is just adding a new block to the file.

## How Applications Use This File

### VSCode Extension

The VSCode extension reads `malloy-config.motly` for connection definitions, using `Malloy.parseConnections()` to create connections from the file. It discovers the file by searching upward from the current directory. Mode selection is a VSCode setting (status bar picker or workspace settings).

### Builder CLI

The builder CLI reads the same file for connections:

```
malloy build pipeline.malloy              # Uses default connections
malloy build --mode staging .             # Uses staging mode connections
```

### Other Tools

Any tool that compiles or runs Malloy models can use `malloy-config.motly`:

```
malloy-dbt model.malloy -c malloy-config.motly --mode staging -o ./dbt-output
```

Applications with their own connection management (like Malloy Publisher) are not required to read this file. They may:

- Ignore it entirely and use their own configuration
- Generate one when they need the builder or VSCode to work with the same connections
- Read it as a convenience

The file is a shared convention, not a requirement.

## Connection Registry

Today, the VSCode extension and the CLI each contain their own copy of the same pattern: a factory that switches on the connection's backend to construct the appropriate `Connection` object, and a `DynamicConnectionLookup` that wraps it for lazy creation. Adding a new connection kind means updating every tool. The connection registry eliminates this duplication.

### Architecture

The registry has three layers:

**1. `@malloydata/malloy` (core) — owns the registry and config parser**

```typescript
// Registration API — called by connection packages
Malloy.registerConnectionType(
  typeName: string,
  factory: (config: ConnectionConfig) => Connection
)

// Consumption API — called by applications
Malloy.parseConnections(
  configText: string,
  options?: { mode?: string }
) → LookupConnection<Connection>
```

`parseConnections` parses the MOTLY config text, resolves mode overrides, and returns a `LookupConnection` that lazily creates connections using the registered factories. Applications pass the result directly to `Runtime`.

**2. Connection packages — register on import**

Each connection package registers its factory as a side effect of being imported:

```typescript
// In @malloydata/db-duckdb
import {Malloy} from '@malloydata/malloy';

Malloy.registerConnectionType('duckdb', (config) => {
  return new DuckDBConnection({
    name: config.name,
    databasePath: config.properties.path ?? ':memory:',
    workingDirectory: config.workingDirectory,
  });
});
```

The same pattern applies to `@malloydata/db-bigquery`, `@malloydata/db-postgres`, etc.

**3. `@malloydata/all-connections` — convenience package**

A single package that re-exports all supported connection packages:

```typescript
// In @malloydata/all-connections
import '@malloydata/db-duckdb';
import '@malloydata/db-bigquery';
import '@malloydata/db-postgres';
import '@malloydata/db-snowflake';
import '@malloydata/db-trino';
import '@malloydata/db-mysql';
```

When a new connection type is added to this package, all applications that import `@malloydata/all-connections` gain support automatically.

### Application Usage

With the registry, application code reduces to:

```typescript
import '@malloydata/all-connections';  // or just the ones you need
import {Malloy, Runtime} from '@malloydata/malloy';
import {readFileSync} from 'fs';

const configText = readFileSync('malloy-config.motly', 'utf-8');
const connections = Malloy.parseConnections(configText, {mode: 'staging'});

const runtime = new Runtime({urlReader, connections});
```

- **VSCode extension**: Imports `@malloydata/all-connections`, calls `parseConnections` with the config file contents and the user's selected mode.
- **CLI tools**: Same pattern, with mode from `--mode` flag.
- **Lightweight tools** (e.g., a DuckDB-only build tool): Import only `@malloydata/db-duckdb`.

### What Applications Still Own

- **Choosing which connection packages to import** — this is the application's decision about which backends it supports.
- **Finding the config file** — searching upward from the model directory, reading from a settings path, etc.
- **Selecting the mode** — from a CLI flag, UI picker, environment variable, or default.

## Future Considerations

- **Connection indirection**: A future mechanism could allow the configuration file to import connections from an external source (another file, a URL) rather than defining them inline. This would support scenarios where connection definitions are managed centrally.
