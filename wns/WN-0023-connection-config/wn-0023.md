# WN 0023 - Malloy Shared Configuration

- **Status**: *Experimental*
- **Discussions-To:** TBD
- **Author:** Michael Toy

## Overview

Malloy tools — the VSCode extension, the builder CLI, and potentially others — need to agree on database connection configurations. This WN defines a shared configuration file format and a connection registry for that purpose.

The configuration file is named `malloy-config.json`. It defines named database connections using JSON. The file itself is a shared convention — config data could come from anywhere. The registry API expects the application to have obtained config data from somewhere and to pass it in as a parsed object.

The Malloy core (`@malloydata/malloy`) provides the **connection registry**. Connection packages (like `@malloydata/db-duckdb`) register their factory functions and property metadata as a side effect of being imported. The core provides functions to parse config data, create connections from it, and query what connection types are available and what properties they accept. Applications import whichever connection packages they need, then use the registry to turn config data into live connections.

## The Configuration File

A minimal configuration declares one connection:

```json
{
  "connections": {
    "duckdb": {
      "is": "duckdb"
    }
  }
}
```

A more complete example:

```json
{
  "connections": {
    "warehouse": {
      "is": "bigquery",
      "projectId": {"env": "GCP_PROJECT"},
      "location": "US"
    },
    "logs": {
      "is": "postgres",
      "host": {"env": "PG_HOST"},
      "port": 5432,
      "databaseName": "analytics",
      "username": {"env": "PG_USER"},
      "password": {"env": "PG_PASSWORD"}
    },
    "local": {
      "is": "duckdb"
    }
  }
}
```

The `connections` object declares named database connections. Malloy models reference connections by name (e.g., `source: foo is warehouse.table('orders')`), and the configuration provides the actual settings for each name. The first connection listed is the default — it is used when a model does not specify a connection name.

Each connection has an `is` property that identifies which registered backend handles it, along with backend-specific properties. For example, a DuckDB connection might have `databasePath` and `motherDuckToken`, while a PostgreSQL connection has `host`, `port`, `username`, `password`, and `databaseName`. The supported backends and their full property lists are documented by the connection packages themselves.

### Environment Variable References

Any string property value can be replaced with an `{"env": "VAR"}` reference. These are resolved from `process.env` at connection creation time. If the referenced environment variable is not set, that property is omitted. This keeps secrets out of the configuration file.

## Connection Registry

The VSCode extension and the CLI used to each contain their own copy of the same pattern: a factory that switches on the connection's backend to construct the appropriate `Connection` object, and a `DynamicConnectionLookup` that wraps it for lazy creation. Adding a new connection kind meant updating every tool. The connection registry eliminates this duplication.

### How It Works

The registry is a three-layer system:

**1. Core (`@malloydata/malloy`)** — owns the registry and the config API. It stores registered connection types, parses config data, and creates connections on demand. When asked to create connections from config, it returns a `LookupConnection` — a lazy resolver that creates and caches connections on first use. The result is passed directly to `Runtime`.

**2. Connection packages** — each `@malloydata/db-*` package registers itself as a side effect of being imported. For example, importing `@malloydata/db-duckdb` registers the `duckdb` type with its factory function and property metadata. The application controls which backends are available simply by choosing which packages to import.

**3. `@malloydata/malloy-connections`** — a convenience package that imports all six database packages (`db-bigquery`, `db-duckdb`, `db-mysql`, `db-postgres`, `db-snowflake`, `db-trino`) for side-effect registration. The `db-trino` package also registers the `presto` type.

### What Applications Own

The registry handles connection creation, but everything else is the application's responsibility:

- **Which connection packages to import** — this determines which backends are available.
- **Where the config comes from** — searching for `malloy-config.json`, reading from settings, generating it programmatically, etc. The API operates on parsed config objects, not files.
- **File I/O** — the config read/write functions operate on strings; the application handles reading and writing files.

### Property Type System

Each registered connection type provides a `properties` array describing the configuration fields it accepts. Each property definition includes a name, a human-readable display name, and a type that tells applications what kind of UI control to present:

| Property Type | UI Control |
|---------------|-----------|
| `string` | Text input |
| `number` | Number input |
| `boolean` | Checkbox |
| `password` | Masked input (credentials, passphrases) |
| `file` | File picker (with optional `fileFilters` for extension filtering) |
| `text` | Multi-line text input (used for `setupSQL`) |

Property definitions can also include `optional` (whether the field is required), `default` (a default value hint), and `description` (explanatory text). Applications can query the registry for registered type names and their property definitions to build dynamic configuration UIs — for example, the VSCode extension can generate a connection settings editor without hardcoding knowledge of each backend's fields.

## Manifest Path

The config file can also declare where persistence manifests are stored:

```json
{
  "connections": {
    "duckdb": {"is": "duckdb"}
  },
  "manifestPath": "MANIFESTS"
}
```

The `manifestPath` property is optional and defaults to `"MANIFESTS"`. The actual manifest file is `<manifestPath>/malloy-manifest.json` relative to the config file location. See WN-0022 for the full persistence design.

## MalloyConfig Class

The `MalloyConfig` class in `@malloydata/malloy` is the primary API for working with config files. It handles parsing the config, creating connections from the registry, and loading the manifest.

```typescript
import {Runtime, MalloyConfig} from '@malloydata/malloy';
import '@malloydata/db-duckdb';

// From a URL — reads config + manifest via URLReader
const config = new MalloyConfig(urlReader, configURL);
await config.load();

const runtime = new Runtime({
  urlReader,
  connections: config.connections,
  buildManifest: config.manifest.buildManifest,
});
```

Config can also be created from a string for cases where the application already has the JSON text:

```typescript
const config = new MalloyConfig(configText);
// config.connections is ready immediately
// config.manifest exists but is empty (no file to load)
```

The connection map can be mutated before accessing `connections`, which is useful for patching in working directories or adding connections programmatically:

```typescript
config.connectionMap!['newdb'] = {is: 'duckdb', database: 'new.db'};
const runtime = new Runtime({connections: config.connections, urlReader});
```

## How Applications Use This

### VSCode Extension

The VSCode extension discovers `malloy-config.json` by searching upward from the current directory. It imports `@malloydata/malloy-connections` to register all backends, creates a `MalloyConfig` from the file, and uses it to build a Runtime with connections and manifest. It also uses the property metadata to build a dynamic connection settings UI.

### Builder CLI

The builder CLI reads the same config file via `MalloyConfig`, uses the connections and manifest to compile models, walk the build plan, and write updated manifests.

### Malloy Publisher

Publisher generates a `malloy-config.json` for use by the VSCode extension and other tools that need to work with the same connections.

### Other Tools

Any tool that compiles or runs Malloy models can use `malloy-config.json` via `MalloyConfig`. The file is a shared convention — tools can also create `MalloyConfig` from a string or generate config programmatically. The API doesn't care where the data came from.

## Future Considerations

- **Modes**: The persist system (WN-0022) introduces modes — named environment variants like "User" and "Production". Modes will likely need to override connection settings (e.g., different BigQuery projects for staging vs production). The design for how connections and modes interact is still being worked out.