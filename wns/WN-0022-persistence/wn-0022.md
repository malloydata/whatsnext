# WN 0022 - Persistent Sources

- **Status**: *Experimental*
- **Discussions-To:** TBD
- **Author:** Michael Toy
- **Experiment-ID:** persistence

## Overview

As complex data is mined for information, inevitably there will be transformations which are expensive to compute. It is often very helpful to have these intermediate results stored as a table rather than re-computing them every time they are used. In Malloy the mechanism for doing this is called "persistent sources"

Persistence in data computations is a large and complicated problem. There are questions of caching, invalidation, scheduling, garbage collection, production vs. staging environments, developer workflows, and much more. Rather than attempt to solve all of persistence, the Malloy API provides a foundation on which persistence systems can be built. This foundation is deliberately minimal: it provides the machinery for applications to examine models, understand dependencies, and substitute pre-built tables—but leaves all policy decisions to the application layer.

**This feature is experimental and requires the compiler flag `##! experimental.persistence` at the top of any model that uses persistence.**

## The Design Journey: From Queries to Sources

Our initial thinking focused on queries as the unit of persistence. After all, when you persist something, you're persisting the result of running a query.

But as we worked through the design, we realized that although a *query* is what gets executed and persisted, it is always being persisted *as a source*. The persisted table becomes something that other Malloy code references—and references in Malloy are to sources, not queries.

This shift in perspective clarified the design significantly. Two source types are persistable: A normal Malloy query which you would normally define with the `query:` or `run:` statement, and an interpolated SQL SELECT statement (possibly with embedded Malloy)

To mark something as persistent, annotate it with `#@ persist`

```malloy
##! experimental.persistence

#@ persist
source: cleaned_data is duckdb.sql("""
  SELECT *, cleanup(raw_field) as clean_field
  FROM raw_table
""")

#@ persist name=my_schema.feature_table
source: features is cleaned_data -> {
  group_by: category
  aggregate: feature_count is count()
}
```

> _NOTE:_ The annotation `#@ persist` marks a source, beyond that, any interpretation of other data in a persist annotation is left up to the builder application. In this example we imagined a builder which lets you select a table name for the generated table. There could also be data in the `#@ persist` line about table lifetime, or how it behaves in different modes.

### Persistence Inheritance

When a source extends a persistent source, the child inherits persistence. This is natural—if the base data is worth persisting, derived versions of it usually are too.

```malloy
#@ persist
source: cleaned_data is raw_table extend {
  where: status != 'deleted'
}

// Also persistent — inherits from cleaned_data
source: with_features is cleaned_data extend {
  dimension: name_upper is upper(name)
}
```

To break the inheritance chain, use `#@ -persist`:

```malloy
// NOT persistent, despite extending a persistent source
#@ -persist
source: ephemeral_view is cleaned_data extend { ... }
```

### SQL Interpolation

Persistent sources can appear inside SQL blocks via `%{ }` interpolation. When a manifest is available, the interpolated reference resolves to the persisted table rather than expanding inline:

```malloy
#@ persist
source: cleaned_data is raw_table extend {
  where: status != 'deleted'
}

#@ persist
source: embeddings is conn.sql("""
  SELECT * FROM ML.GENERATE_EMBEDDING(
    MODEL `my_model`,
    (SELECT content, id FROM %{ cleaned_data })
  )
""")
```

This is particularly useful for ML pipelines and other workflows where intermediate results feed into raw SQL operations.

### Imports

When a model imports a source from another model that uses persistence, the persistence annotation is preserved. A builder examining the importing model will see the full dependency graph, including dependencies that originate in imported models.

## The Core API: Two Pieces

The persistence foundation provides exactly two capabilities:

### 1. Examining the Model: Build Plans and Dependency Graphs

An application (a "builder") can examine a compiled model and get a complete picture of what needs to be built:

```typescript
const model = await runtime.loadModel(modelUrl);
const buildPlan = model.getBuildPlan();
```

The build plan contains:
- A list of all persistable sources in the model
- The dependency graph between them (which sources depend on which)
- The information needed to compute cache keys

The dependency graphs are organized by connection, enabling builders to parallelize work across different databases. Within each graph, sources are leveled by their dependencies—a source only appears in a level after all its dependencies.

This allows a builder to walk the graph in topological order, building each source in turn. The builder controls all the details: where tables are created, how they're named, how long they persist, whether to use tables or views.

One of the outputs of a builder is a data structure we are calling a **manifest**, which is a record of what got built and what the names of the build artifacts are on the SQL server.

### 2. Running with a Manifest: Table Substitution

When running queries, an application sets a **manifest** on the Runtime. The manifest is typically loaded from a `malloy-config.json` file alongside the model, but it can also be set directly.

```typescript
// Set at construction — queries automatically use it
const runtime = new Runtime({
  urlReader,
  connections: config.connections,
  buildManifest: config.manifest.buildManifest,
});

const result = await runtime
  .loadModel(modelUrl)
  .loadQueryByName('my_query')
  .run();

// Or set/change after construction
runtime.buildManifest = manifest.buildManifest;

// Override per-query: pass empty {} to suppress substitution
const rawSQL = await runtime
  .loadQuery(modelUrl, {buildManifest: {}})
  .getSQL();
```

The API handles all the details internally. When the compiler encounters a persistent source, it:
1. Computes the source's **BuildID** (a hash of the connection configuration and the source's SQL)
2. Looks up that BuildID in the manifest
3. If found, substitutes `SELECT * FROM <table_name>` instead of expanding the source's query

If the source isn't in the manifest, the compiler simply expands it inline—the query will still run, just without the benefit of the pre-built table.

## Identity: SourceID and BuildID

Each persistent source has two identities. The builder app needs to understand these two identities.

**SourceID**
- This is the "name" of a persistent source in the build plan's dependency graph.
- Stable across compilations
- It currently is readable as 'sourceName@modelURL', it may eventually become a digest hash.

**BuildID**
- Used as the cache key in the manifest
- Changes when the source's SQL changes OR when connection configuration changes
- Is a digest made out of connection parameters and the SQL
  * Connection parameters included in the BuildID because two different connections might have connection setups like default schema or schema pathing which would cause the same SQL to generate different results.

The manifest is keyed by BuildID. This captures both the logical content of the source (its SQL) and the context in which it will run (the connection). Two users with different connection parameters will have different BuildIDs for the same source—and appropriately so, since their built tables may differ. Also, two sources with identical SQL will resolve to the same BuildID.

## The User Experience of Persistence

Because the manifest is optional, persistence supports very different user experiences depending on what the application provides:

**No manifest (development)**: Everything expands inline. The model runs exactly as if no `#@ persist` annotations existed. This is the default—persistence is invisible until you opt in.

**Partial manifest (incremental build)**: Some sources are pre-built, others expand inline. A builder can use this to do incremental work: build what's missing, skip what's fresh. The compiler doesn't care which sources are in the manifest and which aren't.

**Full manifest with `strictPersist` (production)**: The `strictPersist` option tells the compiler to fail if any persistent source is missing from the manifest. This catches configuration errors in production—if a table should have been built but wasn't, you find out at compile time rather than by accidentally running an expensive query.

These modes require no changes to the Malloy model itself. The same `.malloy` file works in all three scenarios; the difference is entirely in what the application passes to the compiler.

## What This Enables

By providing only these two primitives—graph examination and manifest substitution—the foundation enables a variety of persistence strategies without prescribing any:

**Production vs. Staging**: A builder can maintain separate manifests for different environments. The same Malloy model compiles against whichever manifest you provide.

**Different Persistence Strategies**: Builders can persist to temporary tables, permanent tables, or even views. They can use UUID-based naming with view indirection, or simple table replacement. The Malloy API doesn't care.

**Custom Invalidation**: Builders control when to rebuild. They might use timestamps, compare BuildIDs against the manifest, or implement sophisticated dependency-aware invalidation.

**Garbage Collection**: Since builders control table creation, they also control cleanup. They might implement mark-and-sweep GC using the build plan, or rely on temporary table expiration, or maintain no cleanup at all.

## What We Don't Do

The foundation explicitly defers these concerns to the application layer:

- **No scheduling**: When and how often to rebuild is an application decision
- **No storage management**: Where tables live, how they're named, how long they persist
- **No coordination**: If multiple builders might run concurrently, the application handles locking
- **No GC**: Cleaning up old tables is the builder's responsibility
- **No registry**: The manifest is just a data structure; how it's stored and shared is up to you

## Current Limitations

This initial implementation has some restrictions:

- **Parameterized sources** are not supported with persistence
- **Composite sources** are not supported with persistence
