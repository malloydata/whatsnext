# WN 0022 - Persistent Sources

- **Status**: *Experimental*
- **Discussions-To:** TBD
- **Author:** Michael Toy
- **Experiment-ID:** persistence

## Overview

As complex data is mined for information, inevitably there will be transformations which are expensive to compute. It is often very helpful to have these intermediate results stored as a table rather than re-computing them every time they are used. In Malloy the mechanism for doing this is called "persistent sources"

Persistence in data computations is a large and complicated problem. There are questions of caching, invalidation, scheduling, garbage collection, production vs. staging environments, developer workflows, and much more. Rather than attempt to solve all of persistence, the Malloy API provides a **foundation** on which persistence systems can be built. This foundation is deliberately minimal: it provides the machinery for applications to examine models, understand dependencies, and substitute pre-built tables—but leaves all policy decisions to the application layer.

**This feature is experimental and requires the compiler flag `##! experimental.persistence` at the top of any model that uses persistence.**

## The Design Journey: From Queries to Sources

Our initial thinking focused on queries as the unit of persistence. After all, when you persist something, you're persisting the result of running a query.

But as we worked through the design, we realized that although a *query* is what gets executed and persisted, it is always being persisted *as a source*. The persisted table becomes something that other Malloy code references—and references in Malloy are to sources, not queries.

This shift in perspective clarified the design significantly. Two source types are persistable: A normal Malloy query which you would normally define with the `query:` or `run:` statement, and an interpolated SQL SELECT statement (possibly with embedded malloy)

To mark something as persistent, annotate it with `#@ persist`

```malloy
##! experimental.persistence

#@ persist
source: cleaned_data is duckdb.sql("""
  SELECT *, cleanup(raw_field) as clean_field
  FROM raw_table
""")

#@ persist name=my_schema.feature_table
source: features is cleaned_data -> {
  group_by: category
  aggregate: feature_count is count()
}
```

> _NOTE:_ The annotation `#@ persist` marks a source, beyond that, any interpretation of other data in a persist annotation is left up to the builder application. In this example we imagined a builder which lets you select a table name for the generated table. There could also be data in the `#@ persist` line about table lifetime, or how it behaves in different modes.

## The Core API: Two Pieces

The persistence foundation provides exactly two capabilities:

### 1. Examining the Model: Build Plans and Dependency Graphs

An application (a "builder") can examine a compiled model and get a complete picture of what needs to be built:

```typescript
const model = await Malloy.compile({...});
const buildPlan = model.getBuildPlan();
```

The build plan contains:
- A list of all persistable sources in the model
- The dependency graph between them (which sources depend on which)
- The information needed to compute cache keys

The dependency graphs are organized by connection, enabling builders to parallelize work across different databases. Within each graph, sources are leveled by their dependencies—a source only appears in a level after all its dependencies.

This allows a builder to walk the graph in topological order, building each source in turn. The builder controls all the details: where tables are created, how they're named, how long they persist, whether to use tables or views.

### 2. Running with a Manifest: Table Substitution

When running a query, an application can provide a **manifest**—a mapping from source identities to pre-built table names:

```typescript
const result = await runtime
  .loadModel(modelUrl)
  .loadQueryByName('my_query')
  .run({ buildManifest: manifest });
```

The API handles all the details internally. When the compiler encounters a persistent source, it:
1. Computes the source's **BuildID** (a hash of the connection configuration and the source's SQL)
2. Looks up that BuildID in the manifest
3. If found, substitutes `SELECT * FROM <table_name>` instead of expanding the source's query

If the source isn't in the manifest, the compiler simply expands it inline—the query will still run, just without the benefit of the pre-built table.

## Identity: SourceID and BuildID

Each persistent source has two identities. The builder app needs to understand these two identities.

**SourceID**
- This is the "name" of a persistent source in the build plan's dependency graph.
- Stable across compilations
- It currently is readable as 'sourceName@modelURL', it may eventually become a digest hash.

**BuildID**
- Used as the cache key in the manifest
- Changes when the source's SQL changes OR when connection configuration changes
- Is a digest made out of connection parameters and the SQL
  * Connection parameters included in the BuildID because two different connections might have connection setups like default schema or schema pathing which would cause the same SQL to generate different results.

The manifest is keyed by BuildID. This captures both the logical content of the source (its SQL) and the context in which it will run (the connection). Two users with different connection parameters will have different BuildIDs for the same source—and appropriately so, since their built tables may differ. Also, two sources with identical SQL will resolve to the same BuildID.

## What This Enables

By providing only these two primitives—graph examination and manifest substitution—the foundation enables a variety of persistence strategies without prescribing any:

**Production vs. Staging**: A builder can maintain separate manifests for different environments. The same Malloy model compiles against whichever manifest you provide.

**Developer Mode**: Developers can work without a manifest (everything expands inline) or with a partial manifest (only some sources pre-built). The `strictPersist` option can require that all persistent sources be in the manifest, catching configuration errors.

**Different Persistence Strategies**: Builders can persist to temporary tables, permanent tables, or even views. They can use UUID-based naming with view indirection, or simple table replacement. The Malloy API doesn't care.

**Custom Invalidation**: Builders control when to rebuild. They might use timestamps, compare BuildIDs against the manifest, or implement sophisticated dependency-aware invalidation.

**Garbage Collection**: Since builders control table creation, they also control cleanup. They might implement mark-and-sweep GC using the build plan, or rely on temporary table expiration, or maintain no cleanup at all.

## What We Don't Do

The foundation explicitly defers these concerns to the application layer:

- **No scheduling**: When and how often to rebuild is an application decision
- **No storage management**: Where tables live, how they're named, how long they persist
- **No coordination**: If multiple builders might run concurrently, the application handles locking
- **No GC**: Cleaning up old tables is the builder's responsibility
- **No registry**: The manifest is just a data structure; how it's stored and shared is up to you

## The Dependency Paths

## Current Limitations

This initial implementation has some restrictions:

- **Parameterized sources** are not supported with persistence
- **Composite sources** are not supported with persistence
